import ij.*;
import ij.plugin.PlugIn;
import ij.plugin.frame.RoiManager;
import ij.process.*;
import ij.gui.*;
import java.awt.*;
import java.awt.List;
import java.awt.event.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.*;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

	/**
	This plugin implements the MouseListener and MouseMotionListener interfaces 
	and listens for mouse events generated by the current image.
	*/

	/**
	 * 
	 * Algo to detect different events (multipoint move, delete, add, click) is quite messy, and could be cleaner/smarter.
	 * But works...
	 */
	public class UserInputLogger implements PlugIn, MouseListener, ImageListener  { // MouseMotionListener,
		ImagePlus img;
		ImageCanvas canvas;
		static Vector images = new Vector();

		
		// called when an image is opened
		public void imageOpened(ImagePlus imp) {
			if (UserInterface.disableNewImageWarnings) {
				return;
			}
			String imgTitle = imp.getTitle();
			if (imgTitle.equals("peaks") || imgTitle.equals("Filtered output")) { //From 3D counter plugin operation 
					return;
			}
			
			
			img = WindowManager.getCurrentImage();
			Integer id = new Integer(img.getID());
			if (images.contains(id)) {
				//IJ.log("Already listening to this image");
			} else {
				ImageWindow win = img.getWindow();
				canvas = win.getCanvas();
				canvas.addMouseListener(this);
				//canvas.addMouseMotionListener(this);
				//int tool = Toolbar.getInstance().addTool("Test Tool");
				//Toolbar.getInstance().setTool(tool);	
				images.addElement(id);
			}
			//UserInterface.saveAndDisplayEvent(img, "Opened new image: " + imp.getTitle()); //This triggers errors when non-hard-drive images are opened by macros or plugins
		}
		
		
	public void run(String arg) {
		//IJ.log("Image_Listener: starting");
		ImagePlus.addImageListener(this);
	}
	
	public void mousePressed(MouseEvent e) {
		//int x = e.getX();
		//int y = e.getY();
		//int offscreenX = canvas.offScreenX(x);
		//int offscreenY = canvas.offScreenY(y);
		//IJ.log("Mouse pressed: "+offscreenX+","+offscreenY+modifiers(e.getModifiers()));
		//IJ.log("Right button: "+((e.getModifiers()&Event.META_MASK)!=0));

	}
	
	
	public void mouseReleased(MouseEvent e) {
		ImagePlus currentImg = WindowManager.getCurrentImage();
		
		//Every time mouse is released, compare old multipoint list with new. Log changes
		Roi currentRois = currentImg.getRoi();
		
		//Get previous roi state
		Roi prevRois = roiHistory.getValue(currentImg);
		
		//Special condition, when the last/only multipoint is deleted
		if (prevRois != null) { 
			if (currentRois == null && prevRois.size() == 1) {
				String tmp = "Point deleted: xy: [" + prevRois.getXBase() + "," + prevRois.getYBase() + "]";
				tmp = tmp.replace(".0",  "");
				UserInterface.saveAndDisplayEvent(img, tmp);
			}
		}
		
		//Abort conditions:
		if (currentRois == null) {
			if (roiHistory.getValueAllRoisDeleted(currentImg) != null) { //Avoid repeating msg more than once
				if (roiHistory.getValueAllRoisDeleted(currentImg) == false) { //Avoid repeating msg more than once
					UserInterface.saveAndDisplayEvent(img, "All markers removed ( amount of markers before this was = " + prevRois.size() + ")");
					roiHistory.addAllRoisDeleted(currentImg, true);
					return;
				}
			}
			return;
		} else if (!currentRois.getTypeAsString().equals("Point")) { 
			return;
		}
		
		
		if (prevRois != null) { //Dialog pop-up to delete many multipoints that appears if you remove more than 12 
			//mulipoints by clicking another selection on the image does NOT register as mouse release event
			//This condition is to register those events
			if (currentRois.size() == 1 && prevRois.size() > 2) {
				UserInterface.saveAndDisplayEvent(img, "All markers were removed. Single new point created:");
				String tmp = "New point created: xy: [" + currentRois.getXBase() + "," + currentRois.getYBase() + "]";
				tmp = tmp.replace(".0",  "");
				UserInterface.saveAndDisplayEvent(img, tmp);
				//Record new state
				roiHistory.add(currentImg, (Roi) currentRois.clone());
				roiHistory.addAllRoisDeleted(currentImg, false);
				return;
			}
		}

		//Check if new one is created:
		Point createdRoi = null;
		if (currentRois != null) {
			for (Point roiCurrent : currentRois) {
				boolean foundMatch = false;
				if (prevRois != null) { //Avoid null error in below for/each loop
					for (Point roiPrev : prevRois) {
						if (roiCurrent.equals(roiPrev)) {
							foundMatch = true;
						}
					}
				}
				if (!foundMatch) {
					createdRoi = roiCurrent;
				}
			}
		}
		
		//Check if any is deleted (algo above, but with reversing order of currentRois/prevRois):
		Point deletedRoi = null;
		if (prevRois != null) {
			for (Point roiPrev : prevRois) {
				boolean foundMatch = false;
				if (prevRois != null) { //Avoid null error in below for/each loop
						for (Point roiCurrent : currentRois) {
						if (roiCurrent.equals(roiPrev)) {
							foundMatch = true;
						}
					}
				}
				if (!foundMatch) {
					deletedRoi = roiPrev;
				}
			}
		}

		
		//roisWereAllDeleted is to avoid triggering "roi moved" on certain cases.
		boolean roisWereAllDeleted = false;
		if (roiHistory.getValueAllRoisDeleted(currentImg) == null) { //Image never clicked on before. Never trigger "Roi moved".
			roisWereAllDeleted = true;
		} else if (roiHistory.getValueAllRoisDeleted(currentImg) == true) {
			roisWereAllDeleted = true;
		}
		
		
		//DETECT WHEN CLICKING A ROI WITHOUT CHANGING/MOVING IT!
		if  ((roisWereAllDeleted == false) && (prevRois.size() == currentRois.size())) {
			//Convert iterable 1 to string
			ArrayList<Point> tmp1 = new ArrayList<Point>();
			if (currentRois != null) {
				if (prevRois != null) {
					for (Point p : currentRois) {
						tmp1.add(p);
			}}}
			//Convert iterable 2 to string
			ArrayList<Point> tmp2 = new ArrayList<Point>();
			if (currentRois != null) {
				if (prevRois != null) {
					for (Point p : prevRois) {
						tmp2.add(p);
			}}}
			//Compare the two ArrayLists
			if (tmp1.equals(tmp2)) { //A multipoint was clicked, but not moved/changed
				//Record new state
				roiHistory.add(currentImg, (Roi) currentRois.clone());
				roiHistory.addAllRoisDeleted(currentImg, false);
				return;
		}}

		
		//Detect other events
		if  ((roisWereAllDeleted == false) && (prevRois.size() == currentRois.size())) {
			double x1 = deletedRoi.x;
			double y1 = deletedRoi.y;
			double x2 = createdRoi.x;
			double y2 = createdRoi.y;
			double distance = Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
			UserInterface.saveAndDisplayEvent(img, "Roi moved. Old xy: [" + deletedRoi.x + "," + deletedRoi.y + "]. New xy: [" + createdRoi.x + "," + createdRoi.y + "]. Distance = " + distance); 
			//Record new state
			roiHistory.add(currentImg, (Roi) currentRois.clone());
			roiHistory.addAllRoisDeleted(currentImg, false);
			return;
		} 
		
		if (deletedRoi != null && roisWereAllDeleted == false) {
			String tmp = "Point deleted: xy: [" + deletedRoi.getX() + "," + deletedRoi.getY() + "]";
			tmp = tmp.replace(".0",  "");
			UserInterface.saveAndDisplayEvent(img, tmp);
		} 
		if (createdRoi != null) {
			String tmp = "New point created: xy: [" + createdRoi.getX() + "," + createdRoi.getY() + "]";
			tmp = tmp.replace(".0",  "");
			UserInterface.saveAndDisplayEvent(img, tmp);
		}

		//Record new state
		roiHistory.add(currentImg, (Roi) currentRois.clone());
		roiHistory.addAllRoisDeleted(currentImg, false);
	}
	
	
	public static String modifiers(int flags) {
		String s = " [ ";
		if (flags == 0) return "";
		if ((flags & Event.SHIFT_MASK) != 0) s += "Shift ";
		if ((flags & Event.CTRL_MASK) != 0) s += "Control ";
		if ((flags & Event.META_MASK) != 0) s += "Meta (right button) ";
		if ((flags & Event.ALT_MASK) != 0) s += "Alt ";
		s += "]";
		if (s.equals(" [ ]"))
 			s = " [no modifiers]";
		return s;
	}

	public void mouseExited(MouseEvent e) {}
	public void mouseClicked(MouseEvent e) {}
	public void mouseEntered(MouseEvent e) {}
	public void mouseMoved(MouseEvent e) {}


	@Override
	public void imageClosed(ImagePlus imp) {
		// TODO Auto-generated method stub
	}


	@Override
	public void imageUpdated(ImagePlus imp) {
		// TODO Auto-generated method stub
		
	}



}

